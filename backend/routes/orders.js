const express = require('express');
const multer = require('multer');
const path = require('path');
const fs = require('fs');
const Order = require('../models/Order');
const Notification = require('../models/Notification');
const User = require('../models/User');
const { authenticateToken, requireStoreOrAdmin } = require('../middleware/auth');
const { validateOrderCreation, validateObjectId, validatePagination } = require('../middleware/validation');

// Durum etiketleri
const getStatusLabel = (status) => {
  const statusLabels = {
    'siparis_kabul_edildi': '‚úÖ Sipari≈ü Kabul Edildi',
    'siparis_reddedildi': '‚ùå Sipari≈ü Reddedildi',
    'ek_bilgi_gerekli': '‚ÑπÔ∏è Ek Bilgi Gerekli',
    'teslim_tarihi_deƒüi≈üti': 'üìÖ Teslim Tarihi Deƒüi≈üti',
    'fiyat_teklifi': 'üí∞ Fiyat Teklifi',
    'not': 'üìù NOT'
  };
  return statusLabels[status] || status;
};

const router = express.Router();

// Multer konfig√ºrasyonu - ses dosyalarƒ± i√ßin
const storage = multer.diskStorage({
  destination: (req, file, cb) => {
    const uploadDir = path.join(__dirname, '../uploads/voice-recordings');
    if (!fs.existsSync(uploadDir)) {
      fs.mkdirSync(uploadDir, { recursive: true });
    }
    cb(null, uploadDir);
  },
  filename: (req, file, cb) => {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, `voice-${uniqueSuffix}${path.extname(file.originalname)}`);
  }
});

const upload = multer({
  storage: storage,
  limits: {
    fileSize: 10 * 1024 * 1024 // 10MB limit
  },
  fileFilter: (req, file, cb) => {
    // Sadece ses dosyalarƒ±nƒ± kabul et
    if (file.mimetype.startsWith('audio/') || file.originalname.endsWith('.webm')) {
      cb(null, true);
    } else {
      cb(new Error('Sadece ses dosyalarƒ± kabul edilir!'), false);
    }
  }
});

// @route   GET /api/orders
// @desc    Sipari≈üleri listele
// @access  Private
router.get('/', authenticateToken, validatePagination, async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 10;
    const skip = (page - 1) * limit;
    
    const { status, priority, location, assignedTo, createdBy, search, sortBy, sortOrder } = req.query;
    
    // Filtreleme ko≈üullarƒ±
    let filter = {};
    
    // Rol bazlƒ± filtreleme
    if (req.user.role === 'fabrika_iscisi') {
      filter.$or = [
        { assignedTo: req.user._id },
        { assignedTo: null, location: 'fabrika' }
      ];
    } else if (req.user.role === 'magaza_personeli') {
      filter.$or = [
        { createdBy: req.user._id },
        { location: 'magaza' }
      ];
    }
    
    if (status) {
      filter.status = status;
    }
    
    if (priority) {
      filter.priority = priority;
    }
    
    if (location) {
      filter.location = location;
    }
    
    if (assignedTo) {
      filter.assignedTo = assignedTo;
    }
    
    if (createdBy) {
      filter.createdBy = createdBy;
    }
    
    if (search) {
      filter.$or = [
        { title: { $regex: search, $options: 'i' } },
        { orderNumber: { $regex: search, $options: 'i' } },
        { description: { $regex: search, $options: 'i' } }
      ];
    }
    
    // Sƒ±ralama
    let sort = { createdAt: -1 };
    if (sortBy) {
      const order = sortOrder === 'asc' ? 1 : -1;
      sort = { [sortBy]: order };
    }
    
    const orders = await Order.find(filter)
      .populate('createdBy', 'firstName lastName username')
      .populate('assignedTo', 'firstName lastName username')
      .sort(sort)
      .skip(skip)
      .limit(limit);
    
    const total = await Order.countDocuments(filter);
    
    res.json({
      success: true,
      data: {
        orders,
        pagination: {
          current: page,
          pages: Math.ceil(total / limit),
          total,
          limit
        }
      }
    });
  } catch (error) {
    console.error('Get orders error:', error);
    res.status(500).json({
      success: false,
      message: 'Sunucu hatasƒ±',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @route   GET /api/orders/stats
// @desc    Sipari≈ü istatistikleri
// @access  Private
router.get('/stats', authenticateToken, async (req, res) => {
  try {
    let filter = {};
    
    // Rol bazlƒ± filtreleme
    if (req.user.role === 'fabrika_iscisi') {
      filter.$or = [
        { assignedTo: req.user._id },
        { assignedTo: null, location: 'fabrika' }
      ];
    } else if (req.user.role === 'magaza_personeli') {
      filter.$or = [
        { createdBy: req.user._id },
        { location: 'magaza' }
      ];
    }
    
    const totalOrders = await Order.countDocuments(filter);
    
    const statusStats = await Order.aggregate([
      { $match: filter },
      {
        $group: {
          _id: '$status',
          count: { $sum: 1 }
        }
      }
    ]);
    
    const priorityStats = await Order.aggregate([
      { $match: filter },
      {
        $group: {
          _id: '$priority',
          count: { $sum: 1 }
        }
      }
    ]);
    
    const urgentOrders = await Order.countDocuments({
      ...filter,
      $or: [
        { isUrgent: true },
        { priority: 'acil' }
      ]
    });
    
    const overdueOrders = await Order.countDocuments({
      ...filter,
      dueDate: { $lt: new Date() },
      status: { $nin: ['teslim_edildi', 'iptal_edildi'] }
    });
    
    const recentOrders = await Order.find(filter)
      .populate('createdBy', 'firstName lastName username')
      .populate('assignedTo', 'firstName lastName username')
      .sort({ createdAt: -1 })
      .limit(5);
    
    res.json({
      success: true,
      data: {
        totalOrders,
        statusStats,
        priorityStats,
        urgentOrders,
        overdueOrders,
        recentOrders
      }
    });
  } catch (error) {
    console.error('Get order stats error:', error);
    res.status(500).json({
      success: false,
      message: 'Sunucu hatasƒ±',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @route   POST /api/orders
// @desc    Yeni sipari≈ü olu≈ütur
// @access  Private (Store or Admin)
router.post('/', authenticateToken, requireStoreOrAdmin, validateOrderCreation, async (req, res) => {
  try {
    const orderData = {
      ...req.body,
      createdBy: req.user._id
    };
    
    const order = new Order(orderData);
    await order.save();
    
    // Populate edilmi≈ü sipari≈ü bilgilerini al
    const populatedOrder = await Order.findById(order._id)
      .populate('createdBy', 'firstName lastName username')
      .populate('assignedTo', 'firstName lastName username');
    
    // Bildirim olu≈ütur
    await Notification.createGlobal({
      title: 'Yeni Sipari≈ü Olu≈üturuldu',
      message: `${populatedOrder.title} ba≈ülƒ±klƒ± yeni bir sipari≈ü olu≈üturuldu.`,
      type: 'siparis_olusturuldu',
      sender: req.user._id,
      relatedOrder: order._id,
      priority: order.priority,
      actionUrl: `/orders/${order._id}`,
      actionText: 'Sipari≈üi G√∂r√ºnt√ºle'
    }, ['admin', 'fabrika_iscisi']);
    
    // Socket.io ile ger√ßek zamanlƒ± bildirim
    const io = req.app.get('io');
    io.emit('new-order', {
      order: populatedOrder,
      message: 'Yeni sipari≈ü olu≈üturuldu'
    });
    
    res.status(201).json({
      success: true,
      message: 'Sipari≈ü ba≈üarƒ±yla olu≈üturuldu',
      data: {
        order: populatedOrder
      }
    });
  } catch (error) {
    console.error('Create order error:', error);
    res.status(500).json({
      success: false,
      message: 'Sunucu hatasƒ±',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @route   GET /api/orders/:id
// @desc    Belirli bir sipari≈üi getir
// @access  Private
router.get('/:id', authenticateToken, validateObjectId(), async (req, res) => {
  try {
    const order = await Order.findById(req.params.id)
      .populate('createdBy', 'firstName lastName username email')
      .populate('assignedTo', 'firstName lastName username email')
      .populate('notes.user', 'firstName lastName username');
    
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Sipari≈ü bulunamadƒ±'
      });
    }
    
    // Eri≈üim kontrol√º
    if (req.user.role === 'fabrika_iscisi') {
      if (order.assignedTo && order.assignedTo._id.toString() !== req.user._id.toString() && 
          order.location !== 'fabrika') {
        return res.status(403).json({
          success: false,
          message: 'Bu sipari≈üe eri≈üim yetkiniz bulunmuyor'
        });
      }
    } else if (req.user.role === 'magaza_personeli') {
      if (order.createdBy._id.toString() !== req.user._id.toString() && 
          order.location !== 'magaza') {
        return res.status(403).json({
          success: false,
          message: 'Bu sipari≈üe eri≈üim yetkiniz bulunmuyor'
        });
      }
    }
    
    res.json({
      success: true,
      data: {
        order
      }
    });
  } catch (error) {
    console.error('Get order error:', error);
    res.status(500).json({
      success: false,
      message: 'Sunucu hatasƒ±',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @route   PUT /api/orders/:id
// @desc    Sipari≈üi g√ºncelle
// @access  Private
router.put('/:id', authenticateToken, validateObjectId(), async (req, res) => {
  try {
    const order = await Order.findById(req.params.id);
    
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Sipari≈ü bulunamadƒ±'
      });
    }
    
    // Eri≈üim kontrol√º
    const canEdit = req.user.role === 'admin' || 
                   order.createdBy.toString() === req.user._id.toString() ||
                   (order.assignedTo && order.assignedTo.toString() === req.user._id.toString());
    
    if (!canEdit) {
      return res.status(403).json({
        success: false,
        message: 'Bu sipari≈üi d√ºzenleme yetkiniz bulunmuyor'
      });
    }
    
    const oldStatus = order.status;
    
    // G√ºncelleme
    const updatedOrder = await Order.findByIdAndUpdate(
      req.params.id,
      req.body,
      { new: true, runValidators: true }
    )
    .populate('createdBy', 'firstName lastName username')
    .populate('assignedTo', 'firstName lastName username');
    
    // Durum deƒüi≈üikliƒüi bildirimi
    if (oldStatus !== updatedOrder.status) {
      await Notification.createGlobal({
        title: 'Sipari≈ü Durumu G√ºncellendi',
        message: `${updatedOrder.title} sipari≈üinin durumu "${updatedOrder.status}" olarak g√ºncellendi.`,
        type: 'siparis_guncellendi',
        sender: req.user._id,
        relatedOrder: updatedOrder._id,
        priority: updatedOrder.priority,
        actionUrl: `/orders/${updatedOrder._id}`,
        actionText: 'Sipari≈üi G√∂r√ºnt√ºle'
      }, ['admin', 'magaza_personeli', 'fabrika_iscisi']);
      
      // Socket.io ile ger√ßek zamanlƒ± bildirim
      const io = req.app.get('io');
      io.emit('order-updated', {
        order: updatedOrder,
        oldStatus,
        newStatus: updatedOrder.status,
        message: 'Sipari≈ü durumu g√ºncellendi'
      });
    }
    
    res.json({
      success: true,
      message: 'Sipari≈ü ba≈üarƒ±yla g√ºncellendi',
      data: {
        order: updatedOrder
      }
    });
  } catch (error) {
    console.error('Update order error:', error);
    res.status(500).json({
      success: false,
      message: 'Sunucu hatasƒ±',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @route   DELETE /api/orders/:id
// @desc    Sipari≈üi sil
// @access  Private (Admin or Creator)
router.delete('/:id', authenticateToken, validateObjectId(), async (req, res) => {
  try {
    const order = await Order.findById(req.params.id);
    
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Sipari≈ü bulunamadƒ±'
      });
    }
    
    // Sadece admin veya sipari≈ü olu≈üturan silebilir
    if (req.user.role !== 'admin' && order.createdBy.toString() !== req.user._id.toString()) {
      return res.status(403).json({
        success: false,
        message: 'Bu sipari≈üi silme yetkiniz bulunmuyor'
      });
    }
    
    await Order.findByIdAndDelete(req.params.id);
    
    res.json({
      success: true,
      message: 'Sipari≈ü ba≈üarƒ±yla silindi'
    });
  } catch (error) {
    console.error('Delete order error:', error);
    res.status(500).json({
      success: false,
      message: 'Sunucu hatasƒ±',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @route   POST /api/orders/:id/notes
// @desc    Sipari≈üe not ekle
// @access  Private
router.post('/:id/notes', authenticateToken, validateObjectId(), async (req, res) => {
  try {
    const { message } = req.body;
    
    if (!message || message.trim().length === 0) {
      return res.status(400).json({
        success: false,
        message: 'Not mesajƒ± gereklidir'
      });
    }
    
    const order = await Order.findById(req.params.id);
    
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Sipari≈ü bulunamadƒ±'
      });
    }
    
    order.notes.push({
      user: req.user._id,
      message: message.trim()
    });
    
    await order.save();
    
    const updatedOrder = await Order.findById(req.params.id)
      .populate('notes.user', 'firstName lastName username');
    
    res.json({
      success: true,
      message: 'Not ba≈üarƒ±yla eklendi',
      data: {
        notes: updatedOrder.notes
      }
    });
  } catch (error) {
    console.error('Add order note error:', error);
    res.status(500).json({
      success: false,
      message: 'Sunucu hatasƒ±',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @route   PUT /api/orders/:id/assign
// @desc    Sipari≈üi kullanƒ±cƒ±ya ata
// @access  Private (Admin)
router.put('/:id/assign', authenticateToken, validateObjectId(), async (req, res) => {
  try {
    const { assignedTo } = req.body;
    
    if (req.user.role !== 'admin') {
      return res.status(403).json({
        success: false,
        message: 'Sipari≈ü atama yetkisi sadece admin kullanƒ±cƒ±larda bulunur'
      });
    }
    
    const order = await Order.findByIdAndUpdate(
      req.params.id,
      { assignedTo: assignedTo || null },
      { new: true }
    )
    .populate('createdBy', 'firstName lastName username')
    .populate('assignedTo', 'firstName lastName username');
    
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Sipari≈ü bulunamadƒ±'
      });
    }
    
    // Atama bildirimi
    if (assignedTo) {
      await Notification.createForUsers({
        title: 'Size Yeni Sipari≈ü Atandƒ±',
        message: `${order.title} ba≈ülƒ±klƒ± sipari≈ü size atandƒ±.`,
        type: 'siparis_guncellendi',
        sender: req.user._id,
        relatedOrder: order._id,
        priority: order.priority,
        actionUrl: `/orders/${order._id}`,
        actionText: 'Sipari≈üi G√∂r√ºnt√ºle'
      }, [assignedTo]);
    }
    
    res.json({
      success: true,
      message: assignedTo ? 'Sipari≈ü ba≈üarƒ±yla atandƒ±' : 'Sipari≈ü atamasƒ± kaldƒ±rƒ±ldƒ±',
      data: {
        order
      }
    });
  } catch (error) {
    console.error('Assign order error:', error);
    res.status(500).json({
      success: false,
      message: 'Sunucu hatasƒ±',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

// @route   POST /api/orders/:id/responses
// @desc    Sipari≈üe cevap g√∂nder (JSON veya FormData)
// @access  Private (Admin, Fabrika, Maƒüaza)
router.post('/:id/responses', authenticateToken, requireStoreOrAdmin, upload.single('voiceRecording'), async (req, res) => {
  try {
    const { id } = req.params;
    const { status, note } = req.body;
    const userId = req.user._id;
    const userName = req.user.name || req.user.username;

    // Debug log
    console.log('üìù Content-Type:', req.get('Content-Type'));
    console.log('üìù Request body:', req.body);
    console.log('üìù Status:', status, 'Type:', typeof status);
    console.log('üìù Note:', note, 'Type:', typeof note);
    console.log('üìù File:', req.file);

    // Status validation
    if (!status || status.trim() === '') {
      return res.status(400).json({
        success: false,
        message: 'Durum se√ßimi zorunludur'
      });
    }

    // Sipari≈üi bul
    const order = await Order.findById(id);
    if (!order) {
      return res.status(404).json({
        success: false,
        message: 'Sipari≈ü bulunamadƒ±'
      });
    }

    // Cevap objesi olu≈ütur
    const response = {
      status,
      note: note || '',
      userId,
      userName,
      timestamp: new Date(),
      voiceRecording: req.file ? {
        filename: req.file.filename,
        originalName: req.file.originalname,
        path: req.file.path,
        size: req.file.size,
        mimetype: req.file.mimetype
      } : null
    };

    // Sipari≈üe cevabƒ± ekle
    if (!order.responses) {
      order.responses = [];
    }
    order.responses.push(response);

    // Sipari≈üi kaydet
    await order.save();

    // Timeline description'ƒ±nƒ± olu≈ütur - not varsa ekle
    let timelineDescription;
    if (status === 'not') {
      // NOT durumu se√ßildiyse sadece notu g√∂ster
      timelineDescription = `${userName} sipari≈üe not g√∂nderdi: ${note || 'Not eklendi'}`;
    } else {
      // Diƒüer durumlar i√ßin normal mesaj + not
      timelineDescription = `${userName} sipari≈üe cevap verdi: ${getStatusLabel(status)}`;
      if (note && note.trim()) {
        timelineDescription += ` - Not: ${note}`;
      }
    }
    
    // Ses kaydƒ± varsa √∂zel g√∂sterim ekle
    if (response.voiceRecording) {
      timelineDescription += ` üé§ (Ses Kaydƒ±)`;
    }
    
    console.log('üé§ Timeline description with voice recording:', timelineDescription);

    // Timeline'a cevap ekle
    const timelineEntry = {
      type: 'response',
      description: timelineDescription,
      timestamp: new Date(),
      user: userName,
      status: status,
      note: note,
      voiceRecording: response.voiceRecording
    };
    
    // Timeline array'ini kontrol et ve ekle
    if (!order.timeline) {
      order.timeline = [];
    }
    order.timeline.push(timelineEntry);
    
    // Sipari≈üi tekrar kaydet
    await order.save();
    
    console.log('Timeline entry added:', timelineEntry);
    console.log('Order timeline length:', order.timeline.length);

    // Bildirim mesajƒ±nƒ± olu≈ütur - NOT durumu i√ßin √∂zel mantƒ±k
    let notificationMessage;
    if (status === 'not') {
      // NOT durumu se√ßildiyse sadece notu g√∂ster
      notificationMessage = `${userName} sipari≈ü ${id} i√ßin not g√∂nderdi: ${note || 'Not eklendi'}`;
    } else {
      // Diƒüer durumlar i√ßin normal mesaj + not
      notificationMessage = `${userName} sipari≈ü ${id} i√ßin cevap g√∂nderdi: ${getStatusLabel(status)}`;
      if (note && note.trim()) {
        notificationMessage += ` - Not: ${note}`;
      }
    }

    // Bildirim alƒ±cƒ±larƒ±nƒ± belirle - hem sipari≈ü sahibine hem de atanan ki≈üiye
    const recipients = [{
      user: order.createdBy, // Sipari≈ü sahibine bildirim g√∂nder
      isRead: false
    }];
    
    // Eƒüer sipari≈ü atanmƒ±≈üsa ve atanan ki≈üi g√∂nderen deƒüilse, ona da bildirim g√∂nder
    if (order.assignedTo && order.assignedTo.toString() !== userId.toString()) {
      recipients.push({
        user: order.assignedTo,
        isRead: false
      });
    }

    // Bildirim olu≈ütur
    const notification = new Notification({
      type: 'siparis_cevabi',
      title: 'Sipari≈ü Cevabƒ±',
      message: notificationMessage,
      sender: userId, // G√∂nderen kullanƒ±cƒ±
      recipients: recipients,
      relatedOrder: order._id,
      priority: 'normal'
    });
    await notification.save();

    // Socket.io ile real-time bildirim g√∂nder
    const io = req.app.get('io');
    if (io) {
    console.log('Socket.io bildirim g√∂nderiliyor...');
    console.log('G√∂nderen userId:', userId.toString());
    console.log('G√∂nderen userName:', userName);
    console.log('Order createdBy:', order.createdBy.toString());
    console.log('Order assignedTo:', order.assignedTo ? order.assignedTo.toString() : 'null');
    console.log('Order ID:', order._id.toString());
      
      // Room'daki kullanƒ±cƒ± sayƒ±sƒ±nƒ± kontrol et
      const room = io.sockets.adapter.rooms.get(`user-${order.createdBy}`);
      console.log(`Room user-${order.createdBy} kullanƒ±cƒ± sayƒ±sƒ±:`, room ? room.size : 0);
      
      // Sipari≈ü sahibine bildirim g√∂nder
      const notificationData = {
        type: 'siparis_cevabi',
        title: 'Sipari≈ü Cevabƒ±',
        message: notificationMessage, // Not ile birlikte mesaj
        orderId: order._id.toString(),
        timestamp: new Date()
      };
      
      const orderUpdateData = {
        orderId: order._id.toString(),
        type: 'response_added',
        response: response,
        timelineEntry: timelineEntry
      };
      
      console.log('newNotification data:', notificationData);
      console.log('orderUpdated data:', orderUpdateData);
      
      // T√ºm ilgili kullanƒ±cƒ±lara bildirim g√∂nder
      const targetRooms = new Set();
      
      // Sipari≈ü sahibine bildirim g√∂nder - ama g√∂nderen kendisi deƒüilse
      if (order.createdBy.toString() !== userId.toString()) {
        targetRooms.add(`user-${order.createdBy}`);
      }
      
      // Eƒüer sipari≈ü atanmƒ±≈üsa ve atanan ki≈üi g√∂nderen deƒüilse, ona da bildirim g√∂nder
      if (order.assignedTo && order.assignedTo.toString() !== userId.toString()) {
        targetRooms.add(`user-${order.assignedTo}`);
      }
      
      // G√∂nderen kullanƒ±cƒ±nƒ±n kendi odasƒ±na bildirim g√∂nderme - kendi g√∂nderdiƒüi mesajƒ± pop-up olarak g√∂rmesin
      // targetRooms.add(`user-${userId}`); // Bu satƒ±rƒ± kaldƒ±rdƒ±k

      // Eƒüer g√∂nderen admin ise, t√ºm fabrika kullanƒ±cƒ±larƒ±nƒ± da hedeflere ekle
      // Bu, admin'in g√∂nderdiƒüi mesajlarƒ±n fabrika paneline real-time yansƒ±masƒ±nƒ± saƒülar.
      if (req.user.role === 'admin') {
          const factoryUsers = await User.find({ role: 'fabrika_iscisi' });
          factoryUsers.forEach(factoryUser => {
              if (factoryUser && factoryUser._id.toString() !== userId.toString() && !targetRooms.has(`user-${factoryUser._id.toString()}`)) {
                  targetRooms.add(`user-${factoryUser._id.toString()}`);
                  console.log(`Admin g√∂nderdiƒüi i√ßin fabrika kullanƒ±cƒ±sƒ± ${factoryUser._id.toString()} hedeflere eklendi.`);
              }
          });
      }
      
      // Her room'a bildirim g√∂nder
      targetRooms.forEach(room => {
        const roomSockets = io.sockets.adapter.rooms.get(room);
        console.log(`Room ${room} kullanƒ±cƒ± sayƒ±sƒ±:`, roomSockets ? roomSockets.size : 0);
        io.to(room).emit('newNotification', notificationData);
        io.to(room).emit('orderUpdated', orderUpdateData);
      });

      console.log('Socket.io bildirimleri g√∂nderildi');
    } else {
      console.log('Socket.io instance bulunamadƒ±!');
    }

    res.status(201).json({
      success: true,
      message: 'Cevap ba≈üarƒ±yla g√∂nderildi',
      data: {
        response,
        order
      }
    });
  } catch (error) {
    console.error('Send response error:', error);
    res.status(500).json({
      success: false,
      message: 'Sunucu hatasƒ±',
      error: process.env.NODE_ENV === 'development' ? error.message : undefined
    });
  }
});

module.exports = router;