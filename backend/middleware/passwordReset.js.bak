const crypto = require('crypto');
const nodemailer = require('nodemailer');
const User = require('../models/User');

// Email transporter (production'da gerçek SMTP ayarları kullanılmalı)
const transporter = nodemailer.createTransporter({
  host: process.env.SMTP_HOST || 'smtp.gmail.com',
  port: process.env.SMTP_PORT || 587,
  secure: false,
  auth: {
    user: process.env.SMTP_USER || 'your-email@gmail.com',
    pass: process.env.SMTP_PASS || 'your-app-password'
  }
});

// Reset token oluştur
function generateResetToken() {
  return crypto.randomBytes(32).toString('hex');
}

// Reset token'ı hash'le
function hashResetToken(token) {
  return crypto.createHash('sha256').update(token).digest('hex');
}

// Password reset email gönder
async function sendPasswordResetEmail(email, resetToken) {
  const resetUrl = `${process.env.FRONTEND_URL || 'http://localhost:3000'}/reset-password?token=${resetToken}`;
  
  const mailOptions = {
    from: process.env.SMTP_FROM || 'noreply@fabrika.com',
    to: email,
    subject: 'Şifre Sıfırlama - Fabrika Yazılımı',
    html: `
      <div style="font-family: Arial, sans-serif; max-width: 600px; margin: 0 auto;">
        <h2 style="color: #333;">Şifre Sıfırlama</h2>
        <p>Merhaba,</p>
        <p>Fabrika Yazılımı hesabınız için şifre sıfırlama talebinde bulundunuz.</p>
        <p>Şifrenizi sıfırlamak için aşağıdaki butona tıklayın:</p>
        <div style="text-align: center; margin: 30px 0;">
          <a href="${resetUrl}" style="background-color: #007bff; color: white; padding: 12px 24px; text-decoration: none; border-radius: 5px; display: inline-block;">Şifremi Sıfırla</a>
        </div>
        <p>Bu link 1 saat geçerlidir.</p>
        <p>Eğer bu talebi siz yapmadıysanız, bu emaili görmezden gelebilirsiniz.</p>
        <hr style="margin: 30px 0; border: none; border-top: 1px solid #eee;">
        <p style="color: #666; font-size: 12px;">Bu email otomatik olarak gönderilmiştir. Lütfen yanıtlamayın.</p>
      </div>
    `
  };

  try {
    await transporter.sendMail(mailOptions);
    return true;
  } catch (error) {
    console.error('Email gönderme hatası:', error);
    return false;
  }
}

// Password reset token oluştur ve email gönder
async function requestPasswordReset(email) {
  try {
    const user = await User.findOne({ email });
    if (!user) {
      return { success: false, message: 'Bu email adresi ile kayıtlı kullanıcı bulunamadı.' };
    }

    // Reset token oluştur
    const resetToken = generateResetToken();
    const hashedToken = hashResetToken(resetToken);

    // Token'ı veritabanına kaydet (1 saat geçerli)
    user.passwordResetToken = hashedToken;
    user.passwordResetExpires = new Date(Date.now() + 60 * 60 * 1000); // 1 saat
    await user.save();

    // Email gönder
    const emailSent = await sendPasswordResetEmail(email, resetToken);
    
    if (emailSent) {
      return { success: true, message: 'Şifre sıfırlama linki email adresinize gönderildi.' };
    } else {
      return { success: false, message: 'Email gönderilirken bir hata oluştu.' };
    }
  } catch (error) {
    console.error('Password reset hatası:', error);
    return { success: false, message: 'Bir hata oluştu.' };
  }
}

// Password reset token'ı doğrula
async function verifyResetToken(token) {
  try {
    const hashedToken = hashResetToken(token);
    const user = await User.findOne({
      passwordResetToken: hashedToken,
      passwordResetExpires: { $gt: new Date() }
    });

    if (!user) {
      return { success: false, message: 'Geçersiz veya süresi dolmuş token.' };
    }

    return { success: true, user };
  } catch (error) {
    console.error('Token doğrulama hatası:', error);
    return { success: false, message: 'Token doğrulanırken bir hata oluştu.' };
  }
}

// Yeni şifre belirle
async function resetPassword(token, newPassword) {
  try {
    const verification = await verifyResetToken(token);
    if (!verification.success) {
      return verification;
    }

    const user = verification.user;
    
    // Yeni şifreyi hash'le
    const bcrypt = require('bcryptjs');
    const hashedPassword = await bcrypt.hash(newPassword, 12);
    
    // Şifreyi güncelle ve token'ları temizle
    user.password = hashedPassword;
    user.passwordResetToken = undefined;
    user.passwordResetExpires = undefined;
    await user.save();

    return { success: true, message: 'Şifreniz başarıyla güncellendi.' };
  } catch (error) {
    console.error('Şifre sıfırlama hatası:', error);
    return { success: false, message: 'Şifre güncellenirken bir hata oluştu.' };
  }
}

// Password reset middleware
function passwordResetMiddleware() {
  return async (req, res, next) => {
    try {
      const { email, token, newPassword } = req.body;

      if (req.path === '/request-reset' && email) {
        const result = await requestPasswordReset(email);
        return res.json(result);
      }

      if (req.path === '/verify-token' && token) {
        const result = await verifyResetToken(token);
        return res.json(result);
      }

      if (req.path === '/reset-password' && token && newPassword) {
        const result = await resetPassword(token, newPassword);
        return res.json(result);
      }

      next();
    } catch (error) {
      console.error('Password reset middleware hatası:', error);
      res.status(500).json({ success: false, message: 'Sunucu hatası.' });
    }
  };
}

module.exports = {
  requestPasswordReset,
  verifyResetToken,
  resetPassword,
  passwordResetMiddleware
};
